import { ResponseContext, RequestContext, HttpFile, HttpInfo } from '../../../common/http/http';
import { Configuration} from '../../../common/configuration'
import { Observable, of, from } from '../../../common/rxjsStub';
import {mergeMap, map} from  '../../../common/rxjsStub';
import { RobloxThumbnailsApiModelsUniverseThumbnailsResponse } from '../models/RobloxThumbnailsApiModelsUniverseThumbnailsResponse';
import { RobloxThumbnailsApisModelsThumbnailBatchRequest } from '../models/RobloxThumbnailsApisModelsThumbnailBatchRequest';
import { RobloxThumbsFormatType } from '../models/RobloxThumbsFormatType';
import { RobloxThumbsImageParameters } from '../models/RobloxThumbsImageParameters';
import { RobloxWebResponsesThumbnailsThumbnailBatchResponse } from '../models/RobloxWebResponsesThumbnailsThumbnailBatchResponse';
import { RobloxWebResponsesThumbnailsThumbnailResponse } from '../models/RobloxWebResponsesThumbnailsThumbnailResponse';
import { RobloxWebWebAPIModelsApiArrayResponseRobloxThumbnailsApiModelsUniverseThumbnailsResponse } from '../models/RobloxWebWebAPIModelsApiArrayResponseRobloxThumbnailsApiModelsUniverseThumbnailsResponse';
import { RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailBatchResponse } from '../models/RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailBatchResponse';
import { RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse } from '../models/RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse';
import { RobloxWebWebAPIModelsApiErrorModel } from '../models/RobloxWebWebAPIModelsApiErrorModel';

import { AssetsApiRequestFactory, AssetsApiResponseProcessor} from "../apis/AssetsApi";
export class ObservableAssetsApi {
    private requestFactory: AssetsApiRequestFactory;
    private responseProcessor: AssetsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AssetsApiRequestFactory,
        responseProcessor?: AssetsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AssetsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AssetsApiResponseProcessor();
    }

    /**
     * Thumbnails asset animated.
     * @param assetId The asset id.
     * @param robloxPlaceId (optional) placeid
     */
    public v1AssetThumbnailAnimatedGetWithHttpInfo(assetId: number, robloxPlaceId?: number, _options?: Configuration): Observable<HttpInfo<RobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1AssetThumbnailAnimatedGet(assetId, robloxPlaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1AssetThumbnailAnimatedGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Thumbnails asset animated.
     * @param assetId The asset id.
     * @param robloxPlaceId (optional) placeid
     */
    public v1AssetThumbnailAnimatedGet(assetId: number, robloxPlaceId?: number, _options?: Configuration): Observable<RobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1AssetThumbnailAnimatedGetWithHttpInfo(assetId, robloxPlaceId, _options).pipe(map((apiResponse: HttpInfo<RobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

    /**
     * Thumbnails assets.
     * @param assetIds The asset ids.
     * @param robloxPlaceId (optional) placeid
     * @param returnPolicy Optional policy to use in selecting thumbnail to return (default &#x3D; PlaceHolder).
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1AssetsGetWithHttpInfo(assetIds: Array<number>, robloxPlaceId?: number, returnPolicy?: 'PlaceHolder' | 'AutoGenerated' | 'ForceAutoGenerated', size?: '30x30' | '42x42' | '50x50' | '60x62' | '75x75' | '110x110' | '140x140' | '150x150' | '160x100' | '160x600' | '250x250' | '256x144' | '300x250' | '304x166' | '384x216' | '396x216' | '420x420' | '480x270' | '512x512' | '576x324' | '700x700' | '728x90' | '768x432' | '1200x80', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1AssetsGet(assetIds, robloxPlaceId, returnPolicy, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1AssetsGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Thumbnails assets.
     * @param assetIds The asset ids.
     * @param robloxPlaceId (optional) placeid
     * @param returnPolicy Optional policy to use in selecting thumbnail to return (default &#x3D; PlaceHolder).
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1AssetsGet(assetIds: Array<number>, robloxPlaceId?: number, returnPolicy?: 'PlaceHolder' | 'AutoGenerated' | 'ForceAutoGenerated', size?: '30x30' | '42x42' | '50x50' | '60x62' | '75x75' | '110x110' | '140x140' | '150x150' | '160x100' | '160x600' | '250x250' | '256x144' | '300x250' | '304x166' | '384x216' | '396x216' | '420x420' | '480x270' | '512x512' | '576x324' | '700x700' | '728x90' | '768x432' | '1200x80', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1AssetsGetWithHttpInfo(assetIds, robloxPlaceId, returnPolicy, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

    /**
     * Thumbnails assets.
     * @param assetId The asset id.
     * @param robloxPlaceId (optional) placeid
     */
    public v1AssetsThumbnail3dGetWithHttpInfo(assetId: number, robloxPlaceId?: number, _options?: Configuration): Observable<HttpInfo<RobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1AssetsThumbnail3dGet(assetId, robloxPlaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1AssetsThumbnail3dGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Thumbnails assets.
     * @param assetId The asset id.
     * @param robloxPlaceId (optional) placeid
     */
    public v1AssetsThumbnail3dGet(assetId: number, robloxPlaceId?: number, _options?: Configuration): Observable<RobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1AssetsThumbnail3dGetWithHttpInfo(assetId, robloxPlaceId, _options).pipe(map((apiResponse: HttpInfo<RobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

}

import { AvatarApiRequestFactory, AvatarApiResponseProcessor} from "../apis/AvatarApi";
export class ObservableAvatarApi {
    private requestFactory: AvatarApiRequestFactory;
    private responseProcessor: AvatarApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AvatarApiRequestFactory,
        responseProcessor?: AvatarApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AvatarApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AvatarApiResponseProcessor();
    }

    /**
     * Get Avatar 3d object for a user
     * @param userId user Id for avatar
     */
    public v1UsersAvatar3dGetWithHttpInfo(userId: number, _options?: Configuration): Observable<HttpInfo<RobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1UsersAvatar3dGet(userId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1UsersAvatar3dGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Avatar 3d object for a user
     * @param userId user Id for avatar
     */
    public v1UsersAvatar3dGet(userId: number, _options?: Configuration): Observable<RobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1UsersAvatar3dGetWithHttpInfo(userId, _options).pipe(map((apiResponse: HttpInfo<RobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

    /**
     * Get Avatar Busts for the given CSV of userIds
     * @param userIds CSV for the userIds to get avatar headshots
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1UsersAvatarBustGetWithHttpInfo(userIds: Array<number>, size?: '48x48' | '50x50' | '60x60' | '75x75' | '100x100' | '150x150' | '180x180' | '352x352' | '420x420', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1UsersAvatarBustGet(userIds, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1UsersAvatarBustGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Avatar Busts for the given CSV of userIds
     * @param userIds CSV for the userIds to get avatar headshots
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1UsersAvatarBustGet(userIds: Array<number>, size?: '48x48' | '50x50' | '60x60' | '75x75' | '100x100' | '150x150' | '180x180' | '352x352' | '420x420', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1UsersAvatarBustGetWithHttpInfo(userIds, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

    /**
     * Get Avatar Full body shots for the given CSV of userIds
     * @param userIds CSV for the userIds to get avatar full body shots
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1UsersAvatarGetWithHttpInfo(userIds: Array<number>, size?: '30x30' | '48x48' | '60x60' | '75x75' | '100x100' | '110x110' | '140x140' | '150x150' | '150x200' | '180x180' | '250x250' | '352x352' | '420x420' | '720x720', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1UsersAvatarGet(userIds, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1UsersAvatarGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Avatar Full body shots for the given CSV of userIds
     * @param userIds CSV for the userIds to get avatar full body shots
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1UsersAvatarGet(userIds: Array<number>, size?: '30x30' | '48x48' | '60x60' | '75x75' | '100x100' | '110x110' | '140x140' | '150x150' | '150x200' | '180x180' | '250x250' | '352x352' | '420x420' | '720x720', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1UsersAvatarGetWithHttpInfo(userIds, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

    /**
     * Get Avatar Headshots for the given CSV of userIds
     * @param userIds CSV for the userIds to get avatar headshots
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1UsersAvatarHeadshotGetWithHttpInfo(userIds: Array<number>, size?: '48x48' | '50x50' | '60x60' | '75x75' | '100x100' | '110x110' | '150x150' | '180x180' | '352x352' | '420x420' | '720x720', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1UsersAvatarHeadshotGet(userIds, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1UsersAvatarHeadshotGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Avatar Headshots for the given CSV of userIds
     * @param userIds CSV for the userIds to get avatar headshots
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1UsersAvatarHeadshotGet(userIds: Array<number>, size?: '48x48' | '50x50' | '60x60' | '75x75' | '100x100' | '110x110' | '150x150' | '180x180' | '352x352' | '420x420' | '720x720', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1UsersAvatarHeadshotGetWithHttpInfo(userIds, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

}

import { BadgesApiRequestFactory, BadgesApiResponseProcessor} from "../apis/BadgesApi";
export class ObservableBadgesApi {
    private requestFactory: BadgesApiRequestFactory;
    private responseProcessor: BadgesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BadgesApiRequestFactory,
        responseProcessor?: BadgesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BadgesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BadgesApiResponseProcessor();
    }

    /**
     * Thumbnails badge icons.
     * @param badgeIds The badge ids.
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1BadgesIconsGetWithHttpInfo(badgeIds: Array<number>, size?: '150x150', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1BadgesIconsGet(badgeIds, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1BadgesIconsGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Thumbnails badge icons.
     * @param badgeIds The badge ids.
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1BadgesIconsGet(badgeIds: Array<number>, size?: '150x150', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1BadgesIconsGetWithHttpInfo(badgeIds, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

}

import { BatchApiRequestFactory, BatchApiResponseProcessor} from "../apis/BatchApi";
export class ObservableBatchApi {
    private requestFactory: BatchApiRequestFactory;
    private responseProcessor: BatchApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BatchApiRequestFactory,
        responseProcessor?: BatchApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BatchApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BatchApiResponseProcessor();
    }

    /**
     * Returns a list of thumbnails with varying types and sizes
     * @param requests List of ThumbnailBatchRequest objects, may contain the following request types:              1. Avatar              2. AvatarHeadShot              3. GameIcon              4. BadgeIcon              5. GameThumbnail              6. GamePass              7. Asset              8. BundleThumbnail              9. Outfit              10. GroupIcon              11. DeveloperProduct              12. AutoGeneratedAsset              13. AvatarBust              14. PlaceIcon              15. AutoGeneratedGameIcon              16. ForceAutoGeneratedGameIcon              17. Look
     * @param robloxPlaceId (optional) placeid
     */
    public v1BatchPostWithHttpInfo(requests: Array<RobloxThumbnailsApisModelsThumbnailBatchRequest>, robloxPlaceId?: number, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailBatchResponse>> {
        const requestContextPromise = this.requestFactory.v1BatchPost(requests, robloxPlaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1BatchPostWithHttpInfo(rsp)));
            }));
    }

    /**
     * Returns a list of thumbnails with varying types and sizes
     * @param requests List of ThumbnailBatchRequest objects, may contain the following request types:              1. Avatar              2. AvatarHeadShot              3. GameIcon              4. BadgeIcon              5. GameThumbnail              6. GamePass              7. Asset              8. BundleThumbnail              9. Outfit              10. GroupIcon              11. DeveloperProduct              12. AutoGeneratedAsset              13. AvatarBust              14. PlaceIcon              15. AutoGeneratedGameIcon              16. ForceAutoGeneratedGameIcon              17. Look
     * @param robloxPlaceId (optional) placeid
     */
    public v1BatchPost(requests: Array<RobloxThumbnailsApisModelsThumbnailBatchRequest>, robloxPlaceId?: number, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailBatchResponse> {
        return this.v1BatchPostWithHttpInfo(requests, robloxPlaceId, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailBatchResponse>) => apiResponse.data));
    }

}

import { BundlesApiRequestFactory, BundlesApiResponseProcessor} from "../apis/BundlesApi";
export class ObservableBundlesApi {
    private requestFactory: BundlesApiRequestFactory;
    private responseProcessor: BundlesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BundlesApiRequestFactory,
        responseProcessor?: BundlesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BundlesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BundlesApiResponseProcessor();
    }

    /**
     * Get bundle thumbnails for the given CSV of bundle ids
     * @param bundleIds CSV for the bundle ids to get bundle thumbnails
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1BundlesThumbnailsGetWithHttpInfo(bundleIds: Array<number>, size?: '150x150' | '420x420', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1BundlesThumbnailsGet(bundleIds, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1BundlesThumbnailsGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get bundle thumbnails for the given CSV of bundle ids
     * @param bundleIds CSV for the bundle ids to get bundle thumbnails
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1BundlesThumbnailsGet(bundleIds: Array<number>, size?: '150x150' | '420x420', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1BundlesThumbnailsGetWithHttpInfo(bundleIds, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

}

import { DeveloperProductsApiRequestFactory, DeveloperProductsApiResponseProcessor} from "../apis/DeveloperProductsApi";
export class ObservableDeveloperProductsApi {
    private requestFactory: DeveloperProductsApiRequestFactory;
    private responseProcessor: DeveloperProductsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: DeveloperProductsApiRequestFactory,
        responseProcessor?: DeveloperProductsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new DeveloperProductsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new DeveloperProductsApiResponseProcessor();
    }

    /**
     * Thumbnails developer product icons.
     * @param developerProductIds The developer product ids.
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1DeveloperProductsIconsGetWithHttpInfo(developerProductIds: Array<number>, size?: '150x150' | '420x420', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1DeveloperProductsIconsGet(developerProductIds, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1DeveloperProductsIconsGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Thumbnails developer product icons.
     * @param developerProductIds The developer product ids.
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1DeveloperProductsIconsGet(developerProductIds: Array<number>, size?: '150x150' | '420x420', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1DeveloperProductsIconsGetWithHttpInfo(developerProductIds, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

}

import { GamePassesApiRequestFactory, GamePassesApiResponseProcessor} from "../apis/GamePassesApi";
export class ObservableGamePassesApi {
    private requestFactory: GamePassesApiRequestFactory;
    private responseProcessor: GamePassesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GamePassesApiRequestFactory,
        responseProcessor?: GamePassesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GamePassesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GamePassesApiResponseProcessor();
    }

    /**
     * Thumbnails game pass icons.
     * @param gamePassIds The game pass ids.
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1GamePassesGetWithHttpInfo(gamePassIds: Array<number>, size?: '150x150', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1GamePassesGet(gamePassIds, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1GamePassesGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Thumbnails game pass icons.
     * @param gamePassIds The game pass ids.
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1GamePassesGet(gamePassIds: Array<number>, size?: '150x150', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1GamePassesGetWithHttpInfo(gamePassIds, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

}

import { GamesApiRequestFactory, GamesApiResponseProcessor} from "../apis/GamesApi";
export class ObservableGamesApi {
    private requestFactory: GamesApiRequestFactory;
    private responseProcessor: GamesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GamesApiRequestFactory,
        responseProcessor?: GamesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GamesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GamesApiResponseProcessor();
    }

    /**
     * Fetches game icon URLs for a list of universes\' root places. Ids that do not correspond to a valid universe will be filtered out.
     * @param universeIds The universe ids.
     * @param returnPolicy Optional policy to use in selecting game icon to return (default &#x3D; PlaceHolder).
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1GamesIconsGetWithHttpInfo(universeIds: Array<number>, returnPolicy?: 'PlaceHolder' | 'AutoGenerated' | 'ForceAutoGenerated', size?: '50x50' | '128x128' | '150x150' | '256x256' | '420x420' | '512x512', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1GamesIconsGet(universeIds, returnPolicy, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1GamesIconsGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Fetches game icon URLs for a list of universes\' root places. Ids that do not correspond to a valid universe will be filtered out.
     * @param universeIds The universe ids.
     * @param returnPolicy Optional policy to use in selecting game icon to return (default &#x3D; PlaceHolder).
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1GamesIconsGet(universeIds: Array<number>, returnPolicy?: 'PlaceHolder' | 'AutoGenerated' | 'ForceAutoGenerated', size?: '50x50' | '128x128' | '150x150' | '256x256' | '420x420' | '512x512', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1GamesIconsGetWithHttpInfo(universeIds, returnPolicy, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

    /**
     * Fetch game thumbnail URLs for a list of universe IDs.
     * @param universeIds comma-delimited list of universe IDs
     * @param countPerUniverse max number of thumbnails to return per universe
     * @param defaults true if defaults (if any) should be returned if no media exists
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1GamesMultigetThumbnailsGetWithHttpInfo(universeIds: Array<number>, countPerUniverse?: number, defaults?: boolean, size?: '768x432' | '576x324' | '480x270' | '384x216' | '256x144', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxThumbnailsApiModelsUniverseThumbnailsResponse>> {
        const requestContextPromise = this.requestFactory.v1GamesMultigetThumbnailsGet(universeIds, countPerUniverse, defaults, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1GamesMultigetThumbnailsGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Fetch game thumbnail URLs for a list of universe IDs.
     * @param universeIds comma-delimited list of universe IDs
     * @param countPerUniverse max number of thumbnails to return per universe
     * @param defaults true if defaults (if any) should be returned if no media exists
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1GamesMultigetThumbnailsGet(universeIds: Array<number>, countPerUniverse?: number, defaults?: boolean, size?: '768x432' | '576x324' | '480x270' | '384x216' | '256x144', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxThumbnailsApiModelsUniverseThumbnailsResponse> {
        return this.v1GamesMultigetThumbnailsGetWithHttpInfo(universeIds, countPerUniverse, defaults, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxThumbnailsApiModelsUniverseThumbnailsResponse>) => apiResponse.data));
    }

    /**
     * Fetches game thumbnail URLs for a list of universes\' thumbnail ids. Ids that do not correspond to a valid thumbnail will be filtered out.
     * @param universeId 
     * @param thumbnailIds 
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1GamesUniverseIdThumbnailsGetWithHttpInfo(universeId: number, thumbnailIds: Array<number>, size?: '768x432' | '576x324' | '480x270' | '384x216' | '256x144', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1GamesUniverseIdThumbnailsGet(universeId, thumbnailIds, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1GamesUniverseIdThumbnailsGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Fetches game thumbnail URLs for a list of universes\' thumbnail ids. Ids that do not correspond to a valid thumbnail will be filtered out.
     * @param universeId 
     * @param thumbnailIds 
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1GamesUniverseIdThumbnailsGet(universeId: number, thumbnailIds: Array<number>, size?: '768x432' | '576x324' | '480x270' | '384x216' | '256x144', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1GamesUniverseIdThumbnailsGetWithHttpInfo(universeId, thumbnailIds, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

}

import { GroupEmblemApiRequestFactory, GroupEmblemApiResponseProcessor} from "../apis/GroupEmblemApi";
export class ObservableGroupEmblemApi {
    private requestFactory: GroupEmblemApiRequestFactory;
    private responseProcessor: GroupEmblemApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GroupEmblemApiRequestFactory,
        responseProcessor?: GroupEmblemApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GroupEmblemApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GroupEmblemApiResponseProcessor();
    }

    /**
     * Fetches thumbnail URLs for a list of groups. Ids that do not correspond to groups will be filtered out.
     * @param groupIds 
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1GroupsIconsGetWithHttpInfo(groupIds: Array<number>, size?: '150x150' | '420x420', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1GroupsIconsGet(groupIds, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1GroupsIconsGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Fetches thumbnail URLs for a list of groups. Ids that do not correspond to groups will be filtered out.
     * @param groupIds 
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1GroupsIconsGet(groupIds: Array<number>, size?: '150x150' | '420x420', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1GroupsIconsGetWithHttpInfo(groupIds, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

}

import { OutfitsApiRequestFactory, OutfitsApiResponseProcessor} from "../apis/OutfitsApi";
export class ObservableOutfitsApi {
    private requestFactory: OutfitsApiRequestFactory;
    private responseProcessor: OutfitsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: OutfitsApiRequestFactory,
        responseProcessor?: OutfitsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new OutfitsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new OutfitsApiResponseProcessor();
    }

    /**
     * Get 3d object for an outfit
     * @param outfitId CSV for the userIds to get user outfits
     */
    public v1UsersOutfit3dGetWithHttpInfo(outfitId: number, _options?: Configuration): Observable<HttpInfo<RobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1UsersOutfit3dGet(outfitId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1UsersOutfit3dGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get 3d object for an outfit
     * @param outfitId CSV for the userIds to get user outfits
     */
    public v1UsersOutfit3dGet(outfitId: number, _options?: Configuration): Observable<RobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1UsersOutfit3dGetWithHttpInfo(outfitId, _options).pipe(map((apiResponse: HttpInfo<RobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

    /**
     * Get outfits for the given CSV of userOutfitIds
     * @param userOutfitIds CSV for the userOutfitIds to get user outfits
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1UsersOutfitsGetWithHttpInfo(userOutfitIds: Array<number>, size?: '150x150' | '420x420', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1UsersOutfitsGet(userOutfitIds, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1UsersOutfitsGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get outfits for the given CSV of userOutfitIds
     * @param userOutfitIds CSV for the userOutfitIds to get user outfits
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1UsersOutfitsGet(userOutfitIds: Array<number>, size?: '150x150' | '420x420', format?: 'Png' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1UsersOutfitsGetWithHttpInfo(userOutfitIds, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

}

import { PlacesApiRequestFactory, PlacesApiResponseProcessor} from "../apis/PlacesApi";
export class ObservablePlacesApi {
    private requestFactory: PlacesApiRequestFactory;
    private responseProcessor: PlacesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: PlacesApiRequestFactory,
        responseProcessor?: PlacesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new PlacesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new PlacesApiResponseProcessor();
    }

    /**
     * Fetches game icon URLs for a list of places. Ids that do not correspond to a valid place will be filtered out.
     * @param placeIds The place ids.
     * @param returnPolicy Optional policy to use in selecting game icon to return (default &#x3D; PlaceHolder).
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1PlacesGameiconsGetWithHttpInfo(placeIds: Array<number>, returnPolicy?: 'PlaceHolder' | 'AutoGenerated' | 'ForceAutoGenerated', size?: '50x50' | '128x128' | '150x150' | '256x256' | '420x420' | '512x512', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>> {
        const requestContextPromise = this.requestFactory.v1PlacesGameiconsGet(placeIds, returnPolicy, size, format, isCircular, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1PlacesGameiconsGetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Fetches game icon URLs for a list of places. Ids that do not correspond to a valid place will be filtered out.
     * @param placeIds The place ids.
     * @param returnPolicy Optional policy to use in selecting game icon to return (default &#x3D; PlaceHolder).
     * @param size The thumbnail size, formatted widthxheight
     * @param format The thumbnail format
     * @param isCircular The circle thumbnail output parameter, true or false
     */
    public v1PlacesGameiconsGet(placeIds: Array<number>, returnPolicy?: 'PlaceHolder' | 'AutoGenerated' | 'ForceAutoGenerated', size?: '50x50' | '128x128' | '150x150' | '256x256' | '420x420' | '512x512', format?: 'Png' | 'Jpeg' | 'Webp', isCircular?: boolean, _options?: Configuration): Observable<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse> {
        return this.v1PlacesGameiconsGetWithHttpInfo(placeIds, returnPolicy, size, format, isCircular, _options).pipe(map((apiResponse: HttpInfo<RobloxWebWebAPIModelsApiArrayResponseRobloxWebResponsesThumbnailsThumbnailResponse>) => apiResponse.data));
    }

}
